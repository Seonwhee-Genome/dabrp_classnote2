---
title: "정규표현식과 stringr"
author: "박찬엽"
date: "2017년 7월 11일"
output:
  ioslides_presentation:
    widescreen: true
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = T)

```

## 목차

  - 정규표현식
    - 소개
    - 메타문자
    - 함께 사용하는 함수
    - 예시
  - stringr
    - 패키지 소개
    - 실습


## 과제 확인

[예시 코드](https://github.com/mrchypark/dabrp_classnote2/blob/master/assign3.R)

# 정규표현식

## 정규표현식이란

![](http://cfile26.uf.tistory.com/image/2358834252D034FF1E4FE5)

## 정규표현식이란

특정한 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어

-> 문법을 외워야 해서 읽고 사용하기 어려움

-> 익숙해지면 글자를 다루는 코드를 잘 작성할 수 있음

## R의 정규표현식

콘솔에 `?regex`를 입력해 보세요


- 요약
    - 표준문법인 POSIX와 perl방식의 PCRE 2가지가 대표적이며
    - R은 POSIX의 basic과 Extended 중 Extended를 지원
    - `perl = T` 옵션으로 PCRE 방식을 사용할 수도 있음
    
## 메타문자

-`^` : 문자열의 시작    
-`$` : 문자열의 종료    
-`.` : 어떤 문자던 한 개를 표현    
-`[]`: 문자클래스로서 괄호안에 조건에 해당하는 글자 한 개를 표현    
-`?` : 앞에 있는 문자가 없거나 하나    
-`+` : 앞에 있는 문자가 하나 이상    
-`*` : 앞에 있는 문자가 없거나 하나 이상    
-`{n,m}` : 앞 문자가 n개 이상 m개 이하    
-`()` : 하나의 그룹으로 지정하고 글자처럼 취급하며 이후에 \1 등으로 사용 가능

## 단순 매칭

`grep`은 찾고자하는 문자열이 있는지 찾아주는 함수입니다. 단순 매칭의 경우 찾고자하는 패턴에 `character` 데이터를 입력해주면 같은 글자를 가진 `vector`의 위치를 반환합니다.

`grep(찾고자하는 패턴, 대상벡터)`

`?grep`를 실행해서 확인해 보세요.

```{r}
data<-c("apple","banana","banano")
grep("banana", data)
grepl("banana", data)
```

## 문자열의 시작

단순 매칭하는 상황에서 `"`안에 패턴을 작성할 때 `^`을 맨 앞에 같이 사용하면 그 뒤의 글자로 `시작`하는 데이터만 찾습니다.

```{r}
data<-c("apple","banana","banano", "a banana")
grep("banana", data)
grep("^banana", data)
```

## 문자열의 끝

단순 매칭하는 상황에서 `"`안에 패턴을 작성할 때 `$`을 맨 뒤에 같이 사용하면 그 앞의 글자로 `끝`나는 데이터만 찾습니다.

```{r}
data<-c("apple","banana","banano", "a banana", "a banana a")
grep("banana", data)
grep("banana$", data)
```

## 완전히 일치하는 경우만

문자열의 시작과 끝을 강제하는 방법을 배웠으니 완전히 일치하는 방법을 사용할 수 있게 되었습니다.

```{r}
data<-c("apple","banana","banano", "a banana", "a banana a")
grep("banana", data)
grep("^banana$", data)
```

## 임의의 글자 한 개

`.` 은 정규표현식에서 무엇이든 한 개의 글자를 의미합니다.

```{r}
x <- c("apple", "banana", "pear")
grep(".a.", x)
```


## 문자 클래스

문자 클래스를 표현하는 `[]`는 대괄호 안에 있는 글자 하나하나가 문자클래스로 가능한 경우입니다. 예를 들어 `[02468]`이라고 하면 0, 2, 4, 6, 8 중 하나의 글자면 같은 패턴으로 이해합니다.

```{r}
x <- c("123", "1357","999990","1133")
grep("[02468]", x)
```

문자 클래스 내에서는 `^`가 지정한 글자들을 제외하고라는 뜻입니다.

```{r}
x <- c("123", "1357","999990","0200","02468")
grep("[^02468]", x)
```

## 문자 클래스의 연속

작성하는 문자 클래스가 범위를 가질 경우 `-`를 통해서 앞에 글자에서부터 뒤의 글자까지라는 의미로 사용합니다. 예를 들어 숫자 전체는 `[0-9]`로 표현되고 소문자 알파벳 전체라면 `[a-z]`라고 합니다. 알파벳 전체는 `[a-zA-Z]`라고 합니다. 한글도 동작해서 `[ㄱ-ㅎ]`(자음 전체), `[가-힣]`(한글 전체) 등등도 지원합니다.


## 관례적 문자 클래스

문자 클래스는 관례적으로 여러 단축 표현이 있습니다. `[[:xxxx:]]`의 형태를 띄고 의미는 아래와 같습니다.

[[:ascii:]]	 ASCII 문자(모두 128)    
[[:alpha:]]	 알파벳 문자(영문자)    
[[:digit:]]	 숫자    
[[:alnum:]]	 영문자와 숫자    
[[:blank:]]	 빈 문자(스페이스, 탭 등 전체)    
[[:space:]]	 공백 문자    
[[:lower:]]	 소문자    
[[:upper:]]	 대문자    


[기타 문자클래스](https://opentutorials.org/course/730/4570)

## 앞의 글자가 없거나 하나

`?`는 글자 뒤에 붙어서 그 글자가 한개 있거나 없는 경우 모두를 표현할 때 사용합니다.

```{r}
x <- c("apple", "banana", "pear", "aple")
grep("app?", x)
```

## 앞의 글자가 하나 이상

`+`는 글자 뒤에 붙어서 그 글자가 한개 `이상` 연속하는 모두를 표현할 때 사용합니다.

```{r}
x <- c("apple", "banana", "pear", "aple")
grep("p+", x)
grep("ap+", x)
```

## 앞의 글자가 없거나 하나 이상

`*`는 글자 뒤에 붙어서 그 글자가 없는 경우부터 여러 개 연속하는 모두를 표현할 때 사용합니다.

```{r}
x <- c("apple", "banana", "pear", "aple", "abble","appppppppple")
grep("app*", x)
```

## 글자의 갯수를 조절하기

앞의 메타 문자는 모두 없거나 하나, 아니면 갯수와 상관없이 연속되는 경우를 뜻합니다. 그래서 이제 몇 개에서 부터 몇 개까지만 연속하는 것을 찾고 싶을 때 사용하는 문법이 있습니다. `{ }`은 몇 가지 사용법이 있는데,

`{n}`   : 글자가 `n`개인 경우    
`{n, }` : 글자가 `n`개 이거나 더 많은 경우
`{ ,m}` : 글자가 `m`개 이거나 더 적은 경우
`{n,m}` : 글자가 `n`개에서 부터 `m`개 사이에 있는 경우

## 정말 그렇게 동작할까

`a{3}`은 `a`가 3개 연속하는 경우를 뜻합니다. 하지만 `aaaa`또한 3개 연속하는 경우가 그 안에 있기 때문에 조건을 만족하게 됩니다. 이렇기 때문에 항상 생각하는 대로 동작하는지 확인해야 합니다.

```{r}
x <- c("a","aa","aaa","aaaa","aaaaa")
grep("a{3}", x)
grep("^a{3}$", x)
grep("a{3,}", x)
grep("a{,3}", x)
grep("a{2,3}", x)
```


## 그룹화

정규표현식에서는 글자 하나하나를 하나의 개체로 인식합니다. 예를 들어 `abcabcabc`같은 경우 지금 까지 배운 내용으로는 단순 매칭하는 방법밖에 없습니다. 이때 그룹을 사용하면 `(abc)+`이나 `(abc){3}`로 표현할 수 있습니다. `()`는 괄호 안에 있는 글자 전체를 하나의 글자로 인식할 수 있게 해줍니다.

## 함께 사용하는 함수

grep    : 찾고자 하는 패턴이 있는 벡터의 `위치`를 결과로 줌    

grepl   : 찾고자 하는 패턴 인지를 TRUE, FALSE 벡터로 표현    

sub     : 찾고자 하는 첫번째 패턴을 두번째 인자로 바꿈    

gsub    : 찾고자 하는 모든 패턴을 두번째 인자로 바꿈    

dir     : 찾고자 하는 패턴의 파일 이름을 결과로 줌    

strsplit: 자르고자 하는 패턴으로 글자 데이터를 자름    

apropos : Environment에 보여주지 않는 기본 객체들을 보여줌    

* find : 객체가 어디에 포함되어있는지 보여줌    
